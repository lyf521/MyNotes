<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue——api</title>
</head>
<body>
<h5>全局配置</h5>
<p>vue.config是一个对象，包含vue的全局配置。可以在启动应用之前修改下列属性：</p>
<ul>
    <li>
        <h6>silent</h6>
        <dl>
            <dt>类型：boolean</dt>
            <dd>默认值：false</dd>
            <dd>用法：Vue.config.silent = true 取消vue所有的日志和警告</dd>
        </dl>
    </li>
    <li>
        <h6>optionMergeStrategies</h6>
        <dl>
            <dt>类型：{[key:string]:Function}</dt>
            <dd>默认值：{}</dd>
            <dd>用法：Vue.config.optionMergeStrategies._my_option = funciton(parent,child,vm){return child+1}
                const Profile = Vue.extend({
                    _my_option:1
                })
                //Profile.options._my_option = 2
                自定义合并策略的选项
                合并策略选型分别接受在父实例和子实例定义的该选型的值作为第一个和第二个参数，Vue实例上下文被作为第三个参数传入
            </dd>
        </dl>
    </li>
    <li>devtools——配置是否允许vue-devtools检查代码</li>
    <li>errorHandler——指定组件的渲染和观察期未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和Vue实例</li>
    <li>warnHandler——未vue的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略</li>
    <li>ignoredElements——须使Vue忽略在Vue之外的自定义元素（e.g.使用了Web Components APIs）否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于Unknown custom element的警告</li>
    <li>keyCodes——给 v-on 自定义键位别名</li>
    <li>performance——设置为true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API的浏览器上</li>
    <li>productionTip——设置未false以阻止vue在启动时生成生产提示</li>
</ul>
<h5>全局API</h5>
<ul>
    <li>Vue.extend(options)——使用基础Vue构造器，创建一个“子类”。参数是一个包含组件选项的对象。 data选项是特例，需要注意-在 Vue.extend()中它必须是函数</li>
    <li>Vue.nextTick([callback,context])——在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM</li>
    <li>Vue.set(target,key,value)——设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开Vue不能检测属性被添加的限制。***注意对象不能使Vue实例，或者Vue实例根数据对象。</li>
    <li>Vue.delete(target,key)——删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开Vue不能检测到属性被删除的限制，但是你应该很少会使用它。*****目标对象不能是一个Vue实例或Vue实例的根数据对象。</li>
    <li>Vue.directive(id,[definition])——注册或获取全局指令。</li>
    <li>Vue.filter(id,[definition])——注册或获取全局过滤器</li>
    <li>Vue.component(id,[definition])——注册或获取全局组件。注册还会自动使用给定的id设置组件的名称</li>
    <li>Vue.use(plugin)——安装Vue.js插件。如果插件是一个对象，必须提供install方法。如果插件是一个函数，它会被作为install方法。install方法调用时，会将Vue作为参数传入。***当install方法被同一个插件多次调用，插件将只会被安装一次</li>
    <li>Vue.mixin(mixin)——全局注册是一个混入，影响注册之后所有创建的每个Vue实例。插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。</li>
    <li>Vue.compile(template)——在render函数中编译模板字符串。只在独立构建时有效</li>
    <li>Vue.version()——提供字符串形势的Vue安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。</li>
</ul>
<h5>选项/数据</h5>
<ul>
    <li>data——Vue实例的数据对象。Vue将会递归将data的属性转换为getter/setter，从而让data的属性能够响应数据变化。对象必须是纯粹的对象（含有零个或多个的key/value对）：浏览器API创建的原生对象，原型上的属性会被忽略。大概来说，data应该只能是数据-不推荐观察拥有状态行为的对象。<br>一但观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。<br>实例创建之后，可以通过vm.$data 访问原始数据对象。Vue实例也代理了data对象上所有的属性，因此访问 vm.a 等价于访问 vm.$data.a。<br>以 _ 或 $ 开头的属性不会被Vue实例代理，因为他们可能和Vue内置的属性、API方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性。
    <br>当一个组件被定义，data必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供data函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。
    <br>如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(···)) 得到深拷贝的原始数据对象</li>
    <li>props——props可以是数组或对象，用于接受来自父组件的数据。props可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如：类型检测、自定义校验和设置默认值。</li>
    <li>propsData——*只用于 new 创建的实例中。* 创建实例时传递props。主要作用是方便测试。</li>
    <li>computed——计算属性将被混入到Vue实例中。所有getter和setter的this上下文自动地绑定未Vue实例。——计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖（比如非响应式属性）在该实例范畴之外，则计算属性是不会被更新的。</li>
    <li>methods——methods将被混入到Vue实例中。可以直接通过VM实例访问这些方法，或者在指令表达式中使用。方法中的this自动绑定为Vue实例。</li>
    <li>watch——一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue实例将会在实例化时调用 $watch(),遍历watch对象的每一个属性。</li>
</ul>
<h5>选项/DOM</h5>
<ul>
    <li># el——*只在由 new 创建的实例中遵守。*提供一个在页面上已存在的DOM元素作为Vue实例的挂载目标。可以是CSS选择器，也可以是一个HTMLElement实例。
    <br>在实例挂在之后，元素可以用 vm.$el 访问。
    <br>如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。</li>
    <li># template——一个字符串模板作为Vue实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。
    <br>如果值以 # 开始，则它将被用作选择符，并使用匹配元素的innerHTML作为模板。常用的技巧是用<script type="x-template">包含模板。</li>
    <li># render——字符串模板的代替方案，允许你发挥javaScript最大的编程能力。该渲染函数接受一个createElement方法作为第一个参数用来创建 VNode。
    <br>如果组件是一个函数组件，渲染函数还会接受一个额外的 context参数，为没有实例的函数组件提供上下文信息。</li>
    <li># renderError——*只在开发环境下工作。当render函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到renderError。这个功能配合hot-reload非常实用。</li>
</ul>
<h5>选项/生命周期钩子</h5>
        <p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 你不能使用箭头函数来定义一个生命周期方法（例如 created:() => this.fetchTodos()）。这是因为箭头函数绑定了父上下文，因此 this 与你期待的Vue实例不同，this.fetchTodos 的行为未定义。</p>
        <ul>
            <li># beforeCreate——在实例初始化之后，数据观测（data observer）和 event/watcher 事件配置之前被调用</li>
            <li># created——在实例创建完成后被立即调用。在这一步，实例已完成一下的配置：数据观测（data observer），属性 和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</li>
            <li># beforeMount ——在挂载开始之前被调用：相关的 render 函数首次被调用。<br><strong>该钩子在服务器端渲染期间不被调用。</strong></li>
            <li># mounted —— el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当 mounted 被调用时 vnm.$el 也在文档内。
                <br>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted; <strong>该钩子在服务器端渲染期间不被调用</strong>
            </li>
        </ul>
</body>
<script>
 /*# devtools
 * 类型：boolean
 * 默认值：true（生产版为false）
 * 用法：
 * */
    //务必在加载vue之后，立即同步设置一下内容
    Vue.config.devtools = true
    //配置是否允许vue-devtools检查代码。开发版本默认为true，生产版本默认为false。生产版本为true可以启用检查

 /*# errorHandler
 * 类型：Function
 * 默认值：undefined
 * 用法
 * */
    Vue.config.errorHandler = function (err,vm,info) {
        //handle error
        // info 是Vue特定的错误信息，比如错误所在的生命周期钩子
        // 只在2.2.0+可用
    }
    // 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和Vue实例。
    //从2.2.0起，这个钩子也会捕获组件生命周期沟子里的错误。同样的，当这个钩子是undefined时，被捕获的错误会通过 console.error 输出而避免应用崩溃
    //从2.4.0起这个钩子也会捕获Vue自定义事件处理函数内部的错误了
    //错误追踪服务Sentry和Bugsnag都通过此选项提供了官方支持

/*# warnHandler  --2.4.0新增
*类型：Function
* 默认值：undefined
* 用法：*/
    Vue.config.warnHandler = function (msg,vm,trace) {
        //trace 是组建的继承关系追踪
    }
    //为Vue的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。

/*# ignoredElements
* 类型：Array<string | RegExp>
* 默认值：[]
* 用法： */
    Vue.config.ignoredElements = [
        'my-custom-web-component','another-web-component',
        //用一个 'RegExp' 忽略所有“ion-”开头的元素
        //仅在 2.5+ 支持
        /^ion-/
    ]
    //须使Vue忽略在Vue之外的自定义元素（e.g.使用了Web Components APIs）。
    // 否则，它会假设你忘记注册全局组价或者拼错了组件名称，从而跑出一个关于Unknow custom element 的警告

/*# keyCodes
* 类型： { [key：string]：number | Array<number>}
* 默认值：{}
* 用法：*/
    Vue.config.keyCode = {
        v:86,
        f1:112,
        //camelCase 不可用
        mediaPlayPause:179,
        //取而代之的是 kebab-case 且用双引号括起来
        "media-play-pause":179,
        up:[38,87]
    }
    <input type="text" @keyup.media-play-pause="method">
     //给 v-on 自定义键位别名

 /*# performance
 * 类型：boolean
 * 默认值：false（自2.2.3起）
 * 用法：*/
    //设置为true以在浏览器开发工具的性能/时间线面板中启用组件初始化、编译、渲染和打补丁的性能追踪。
    //只适用于开发模式和支持 performance.mark API 的浏览器上

/*# productionTip
* 类型：boolean
* 默认值：true
* 用法： */
    //设置为false 以阻止vue在启动时生成生产提示


















</script>
</html>